<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring注解驱动-扩展原理 | 折木Zxw</title><meta name="description" content="Spring注解驱动-扩展原理BeanFactoryPostProcessorBeanPostProcessor：bean的后置处理器，在bean调用初始化方法前后进行拦截工作的 BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用（也就是所有的bean定义都已经保存加载到BeanFactory中，但是Bean的实例还没有"><meta name="keywords" content="Spring注解驱动,扩展原理,Spring容器的创建流程"><meta name="author" content="折木Zxw"><meta name="copyright" content="折木Zxw"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zxwzxh.github.io/2020/08/26/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-%E6%89%A9%E5%B1%95%E5%8E%9F%E7%90%86/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Spring注解驱动-扩展原理"><meta property="og:url" content="http://zxwzxh.github.io/2020/08/26/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-%E6%89%A9%E5%B1%95%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="折木Zxw"><meta property="og:description" content="Spring注解驱动-扩展原理BeanFactoryPostProcessorBeanPostProcessor：bean的后置处理器，在bean调用初始化方法前后进行拦截工作的 BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用（也就是所有的bean定义都已经保存加载到BeanFactory中，但是Bean的实例还没有"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-08-26T08:07:51.000Z"><meta property="article:modified_time" content="2020-09-01T14:08:22.230Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Spring注解驱动-web" href="http://zxwzxh.github.io/2020/09/01/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-web/"><link rel="next" title="Spring注解驱动-声明式事务" href="http://zxwzxh.github.io/2020/08/24/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">75</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">122</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring注解驱动-扩展原理"><span class="toc-number">1.</span> <span class="toc-text">Spring注解驱动-扩展原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactoryPostProcessor"><span class="toc-number">1.1.</span> <span class="toc-text">BeanFactoryPostProcessor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactoryPostProcessor使用示例"><span class="toc-number">1.1.1.</span> <span class="toc-text">BeanFactoryPostProcessor使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactoryPostProcessor执行原理"><span class="toc-number">1.1.2.</span> <span class="toc-text">BeanFactoryPostProcessor执行原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinitionRegistryPostProcessor"><span class="toc-number">1.2.</span> <span class="toc-text">BeanDefinitionRegistryPostProcessor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinitionRegistryPostProcessor使用示例"><span class="toc-number">1.2.1.</span> <span class="toc-text">BeanDefinitionRegistryPostProcessor使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinitionRegistryPostProcessor执行原理"><span class="toc-number">1.2.2.</span> <span class="toc-text">BeanDefinitionRegistryPostProcessor执行原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationListener"><span class="toc-number">1.3.</span> <span class="toc-text">ApplicationListener</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationListener用法"><span class="toc-number">1.3.1.</span> <span class="toc-text">ApplicationListener用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationListener原理"><span class="toc-number">1.3.2.</span> <span class="toc-text">ApplicationListener原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventListener"><span class="toc-number">1.4.</span> <span class="toc-text">@EventListener</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EventListener使用示例"><span class="toc-number">1.4.1.</span> <span class="toc-text">@EventListener使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventListener原理"><span class="toc-number">1.4.2.</span> <span class="toc-text">@EventListener原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SmartInitializingSingleton原理"><span class="toc-number">1.4.3.</span> <span class="toc-text">SmartInitializingSingleton原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring容器的创建"><span class="toc-number">1.5.</span> <span class="toc-text">Spring容器的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prepareRefresh"><span class="toc-number">1.5.1.</span> <span class="toc-text">prepareRefresh()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#obtainFreshBeanFactory"><span class="toc-number">1.5.2.</span> <span class="toc-text">obtainFreshBeanFactory()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prepareBeanFactory-beanFactory"><span class="toc-number">1.5.3.</span> <span class="toc-text">prepareBeanFactory(beanFactory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#postProcessBeanFactory-beanFactory"><span class="toc-number">1.5.4.</span> <span class="toc-text">postProcessBeanFactory(beanFactory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invokeBeanFactoryPostProcessors-beanFactory"><span class="toc-number">1.5.5.</span> <span class="toc-text">invokeBeanFactoryPostProcessors(beanFactory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#registerBeanPostProcessors-beanFactory"><span class="toc-number">1.5.6.</span> <span class="toc-text">registerBeanPostProcessors(beanFactory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initMessageSource"><span class="toc-number">1.5.7.</span> <span class="toc-text">initMessageSource()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initApplicationEventMulticaster"><span class="toc-number">1.5.8.</span> <span class="toc-text">initApplicationEventMulticaster()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onRefresh"><span class="toc-number">1.5.9.</span> <span class="toc-text">onRefresh()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#registerListeners"><span class="toc-number">1.5.10.</span> <span class="toc-text">registerListeners()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finishBeanFactoryInitialization-beanFactory"><span class="toc-number">1.5.11.</span> <span class="toc-text">finishBeanFactoryInitialization(beanFactory)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#preInstantiateSingletons"><span class="toc-number">1.5.11.1.</span> <span class="toc-text">preInstantiateSingletons()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getBean-beanName"><span class="toc-number">1.5.11.2.</span> <span class="toc-text">getBean(beanName)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doCreateBean-beanName-mbdToUse-args"><span class="toc-number">1.5.11.3.</span> <span class="toc-text">doCreateBean(beanName, mbdToUse, args)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finishRefresh"><span class="toc-number">1.5.12.</span> <span class="toc-text">finishRefresh()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring源码总结"><span class="toc-number">1.6.</span> <span class="toc-text">Spring源码总结</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">折木Zxw</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw categories"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Spring注解驱动-扩展原理</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-26 16:07:51"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-08-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-01 22:08:22"><i class="fas fa-history fa-fw"></i> 更新于 2020-09-01</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Web%E6%A1%86%E6%9E%B6/">Web框架</a><i class="fas fa-angle-right post-meta__separator"></i><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Web%E6%A1%86%E6%9E%B6/Spring/">Spring</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Spring注解驱动-扩展原理"><a href="#Spring注解驱动-扩展原理" class="headerlink" title="Spring注解驱动-扩展原理"></a>Spring注解驱动-扩展原理</h1><h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p><strong>BeanPostProcessor</strong>：bean的后置处理器，在bean调用初始化方法前后进行拦截工作的</p>
<p><strong>BeanFactoryPostProcessor</strong>：BeanFactory的后置处理器，在BeanFactory标准初始化之后调用（<strong>也就是所有的bean定义都已经保存加载到BeanFactory中，但是Bean的实例还没有创建</strong>）</p>
<h3 id="BeanFactoryPostProcessor使用示例"><a href="#BeanFactoryPostProcessor使用示例" class="headerlink" title="BeanFactoryPostProcessor使用示例"></a>BeanFactoryPostProcessor使用示例</h3><p><strong>1、创建一个类实现<code>BeanFactoryPostProcessor</code>接口</strong></p>
<p><code>MyBeanFactoryPostProcessor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyBeanFactoryPostProcessor#postProcessBeanFactory"</span>);</span><br><span class="line">        <span class="comment">//count为容器中定义bean定义的数量</span></span><br><span class="line">        <span class="keyword">int</span> count = beanFactory.getBeanDefinitionCount();</span><br><span class="line">        System.out.println(<span class="string">"Bean的数量为:"</span> + count);</span><br><span class="line">        <span class="comment">//names为容器中定义bean的名称</span></span><br><span class="line">        String[] names = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、编写一个实体类</strong></p>
<p><code>Animal.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal construct..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、编写一个主配置类</strong></p>
<p><code>ExternalConfig.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryPostProcessor <span class="title">myBeanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Animal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、编写测试类进行测试</strong></p>
<p><code>ExternalTest.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(ExternalConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果如下</strong></p>
<img src= "/img/loading.gif" data-src="https://gitee.com/zxwscoffee/img/raw/master/img/image-20200826213619535.png" align="left"/>



<h3 id="BeanFactoryPostProcessor执行原理"><a href="#BeanFactoryPostProcessor执行原理" class="headerlink" title="BeanFactoryPostProcessor执行原理"></a>BeanFactoryPostProcessor执行原理</h3><ol>
<li>调用<code>AnnotationConfigApplicationContext</code>的构造方法创建容器</li>
<li>构造方法中调用了<code>refresh</code>方法</li>
<li><code>refresh</code>方法中调用了<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法来执行<code>BeanFactoryPostProcessor</code></li>
</ol>
<p><strong>BeanFactoryPostProcessor</strong>的查找和执行流程：</p>
<p><strong>1、首先从BeanFactory中获取所有<code>BeanFactoryPostProcessor</code>类型的Bean的名称</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、对<code>BeanFactoryPostProcessor</code>进行分类</strong></p>
<p>按照：</p>
<ul>
<li>实现了<code>PriorityOrdered</code>接口<code>BeanFactoryPostProcessor</code></li>
<li>实现了<code>Ordered</code>接口的<code>BeanFactoryPostProcessor</code></li>
<li>没有实现这两个接口的的普通<code>BeanFactoryPostProcessor</code></li>
</ul>
<p>进行分类</p>
<p><strong>3、调用<code>invokeBeanFactoryPostProcessors</code>方法执行这些<code>BeanFactoryPostProcessor</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//遍历执行每个BeanFactoryPostProcessor的postProcessBeanFactory对象</span></span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>为什么<code>BeanFactoryPostProcessor</code>会在Bean的构造方法执行之前执行？</strong></p>
<p>从源码的<code>refresh()</code>方法中可以看出来：<code>invokeBeanFactoryPostProcessors</code>方法在<code>finishBeanFactoryInitialization</code>方法之前执行！</p>
<h2 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanDefinitionRegistryPostProcessor</code>继承了<code>BeanFactoryPostProcessor</code>接口，添加了一个<code>postProcessBeanDefinitionRegistry</code>方法</p>
<p><strong><code>postProcessBeanDefinitonRegistry</code>方法的执行时机</strong></p>
<p>在所有Bean信息将要被记载到BeanFactory，但是Bean实例还未创建的时候调用</p>
<p>所以这个方法会在<code>BeanFactoryPostProcessor</code>的<code>postProcessBeanFactory</code>方法执行之前调用！</p>
<h3 id="BeanDefinitionRegistryPostProcessor使用示例"><a href="#BeanDefinitionRegistryPostProcessor使用示例" class="headerlink" title="BeanDefinitionRegistryPostProcessor使用示例"></a>BeanDefinitionRegistryPostProcessor使用示例</h3><p><strong>1、自定义类实现<code>BeanDefinitionRegistryPostProcessor</code>接口</strong></p>
<p>在<a href="#BeanFactoryPostProcessor使用示例">BeanFactoryPostProcessor使用示例</a>的基础上添加一个实现了<code>BeanDefinitionRegistryPostProcessor</code>接口的类</p>
<p><code>MyBeanDefinitionRegistryPostProcessor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = registry.getBeanDefinitionCount();</span><br><span class="line">        System.out.println(<span class="string">"容器中Bean的数量:"</span> + count);</span><br><span class="line">        <span class="comment">//给容器中添加一个Bean定义，然后注册到Bean的注册中心中</span></span><br><span class="line">        <span class="comment">//也可以这样创建Bean定义</span></span><br><span class="line">        <span class="comment">// AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Animal.class).getBeanDefinition();</span></span><br><span class="line">        RootBeanDefinition animalDefinition = <span class="keyword">new</span> RootBeanDefinition(Animal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"animal"</span>, animalDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//输出容器中定义bean的数量</span></span><br><span class="line">        <span class="keyword">int</span> count = beanFactory.getBeanDefinitionCount();</span><br><span class="line">        System.out.println(<span class="string">"容器中Bean的数量:"</span> + count);</span><br><span class="line">        <span class="comment">//从容器中获取所有的bean的名称然后输出</span></span><br><span class="line">        String[] names = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、修改配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionRegistryPostProcessor <span class="title">myBeanDefinitionRegistryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBeanDefinitionRegistryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、运行测试方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionRegistryPostProcessor <span class="title">myBeanDefinitionRegistryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanDefinitionRegistryPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<img src= "/img/loading.gif" data-src="https://gitee.com/zxwscoffee/img/raw/master/img/image-20200827102032064.png" align="left"/>



<h3 id="BeanDefinitionRegistryPostProcessor执行原理"><a href="#BeanDefinitionRegistryPostProcessor执行原理" class="headerlink" title="BeanDefinitionRegistryPostProcessor执行原理"></a>BeanDefinitionRegistryPostProcessor执行原理</h3><p><code>BeanDefinitionRegistryPostProcessor</code>是<code>BeanFactoryPostProcessor</code>接口的子接口，所以毫无疑问，<code>BeanDefinitionRegistryPostProcessor</code>肯定是在<code>BeanFactoryPostProcessor</code>的执行流程中执行</p>
<p>在调用<code>invokeBeanFactoryPostProcessors</code>方法执行每个<code>BeanFactoryPostProcessor</code>中的<code>postProcessBeanFactory</code>方法之前，会调用<code>invokeBeanDefinitionRegistryPostProcessors</code>方法来执行每个<code>BeanDefinitionRegistryPostProcessor</code>的<code>postProcessBeanDefinitionRegistry</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也解释了为什么<code>postProcessBeanDefinitionRegistry</code>方法会在<code>postProcessBeanFactory</code>之前执行：</p>
<p>因为<code>invokeBeanDefinitionRegistryPostProcessors</code>方法会在<code>invokeBeanFactoryPostProcessors</code>方法之前调用</p>
<h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><h3 id="ApplicationListener用法"><a href="#ApplicationListener用法" class="headerlink" title="ApplicationListener用法"></a>ApplicationListener用法</h3><p><strong>作用</strong>：监听容器中发布的事件，完成容器的驱动开发</p>
<p><strong>ApplicationListener接口的定义如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle an application event.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要编写一个监听器就要实现<code>ApplicationListener</code>接口，并且要传入一个继承了<code>ApplicationEvent</code>接口的泛型E，所以所监听的事件必须<code>ApplicationEvent</code>及其子类对象</p>
<p><code>MyApplicationListener</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当容器中发布此事件以后，该方法触发</span></span><br><span class="line">    <span class="comment">//这里只要容器中发布了ApplicationEvent类型及其子类型的事件就会触发这个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的事件:"</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(ExternalConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img src= "/img/loading.gif" data-src="https://gitee.com/zxwscoffee/img/raw/master/img/image-20200827224246847.png" align="left"/>

<p>容器中发布了两个<code>ApplicationEvent</code>类型的事件：</p>
<ul>
<li><code>ContextRefreshedEvent</code>：事件在<code>ApplicationContext</code>被初始化或者刷新时触发</li>
<li><code>ContextClosedEvent</code>：事件在<code>ApplicationContext</code>被关闭时触发</li>
</ul>
<p><strong>自定义事件步骤</strong></p>
<ol>
<li><p>写一个监听器来监听某个事件（ApplicationEvent及其子类）</p>
</li>
<li><p>把容器加入到容器中</p>
</li>
<li><p>只要容器中有相关事件的发布，我们就能够监听到这个事件，并调用监听器中的方法</p>
</li>
<li><p>如何发布事件，使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(ExternalConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//发布一个事件</span></span><br><span class="line">    ac.publishEvent(<span class="keyword">new</span> ApplicationEvent(<span class="keyword">new</span> String(<span class="string">"我发布了一个事件"</span>)) &#123;&#125;);</span><br><span class="line">    ac.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<img src= "/img/loading.gif" data-src="https://gitee.com/zxwscoffee/img/raw/master/img/image-20200827225346578.png" align="left"/>



</li>
</ol>
<h3 id="ApplicationListener原理"><a href="#ApplicationListener原理" class="headerlink" title="ApplicationListener原理"></a>ApplicationListener原理</h3><p><strong>ContextRefreshedEvent事件</strong>：</p>
<ol>
<li><p>容器对象创建，构造方法中调用<code>refresh</code>方法</p>
</li>
<li><p>在<code>refresh</code>方法的最后调用了<code>finishRefresh</code>方法来完成容器的刷新</p>
</li>
<li><p><code>finishRefresh</code>方法中调用了<code>publishEvent(new ContextRefreshedEvent(this));</code></p>
<p><strong>事件的发布流程</strong>：</p>
<p>1）获取事件的派发器（多播器）：<code>getApplicationEventMulticaster()</code></p>
<p>2）调用<code>multicastEvent</code>方法来派发事件：</p>
<ul>
<li><p>获取到所有的<code>ApplicationListener</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getApplicationListeners(event, type);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Executor executor = getTaskExecutor();</code>来获取<code>Executor</code></p>
<ul>
<li>如果<code>executor</code>存在，则使用<code>executor</code>来异步执行所有监听器</li>
<li>如果<code>executor</code>不存在（为null），则同步执行所有监听器</li>
</ul>
</li>
</ul>
<p>3）无论是同步还是异步都会调用<code>invokeListener</code>方法来执行监听器，<code>invokeListener</code>做了如下的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取一个异常处理器</span></span><br><span class="line">    ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line">    <span class="comment">//如果异常处理器不为空则使用异常处理器来处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doInvokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            errorHandler.handleError(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有异常处理器，则调用doInvokeListener方法来执行异常处理器</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        doInvokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doInvokeListener</code>方法中回调了<code>listener</code>的<code>onApplicationEvent</code>方法</p>
</li>
</ol>
<p>其他两个事件监听器的执行也是调用了<code>publishEvent</code>方法来实现的！</p>
<p><strong>事件多播器（派发器）是如何获取的？</strong></p>
<p>1）容器创建，调用<code>refresh</code>方法</p>
<p>2）<code>refresh</code>方法中调用了<code>initApplicationEventMulticaster()</code>方法来初始化事件多播器</p>
<ul>
<li>先去容器中查找有没有id为<code>applicationEventMulticaster</code>的组件</li>
<li>如果没有就使用<code>new SimpleApplicationEventMulticaster(beanFactory)</code>创建一个事件多播器，并且加入到容器中。这样我们就可以在其他组件派发事件时，自动注入这个<code>applicationEventMulticaster</code></li>
</ul>
<p><strong>容器中有哪些监听器？</strong></p>
<p>1）容器创建，调用<code>refresh</code>方法</p>
<p>2）<code>refresh</code>方法中调用了<code>registerListeners()</code>方法</p>
<ul>
<li><p>从容器中拿到所有的监听器，把它们注册到事件派发器<code>applicationEventMulticaster</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="EventListener"><a href="#EventListener" class="headerlink" title="@EventListener"></a>@EventListener</h2><p>除了实现<code>ApplicationListener</code>接口的方式来实现对特定事件的监听以外，还可以使用<code>@EventListener</code>注解来指定一个用于监听特定事件的方法</p>
<h3 id="EventListener使用示例"><a href="#EventListener使用示例" class="headerlink" title="@EventListener使用示例"></a>@EventListener使用示例</h3><p><code>AccountService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span>(&#123;</span><br><span class="line">            ApplicationEvent<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">    &#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">listen</span>(<span class="title">ApplicationEvent</span> <span class="title">event</span>) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AccountService监听到事件:"</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：</strong></p>
<img src= "/img/loading.gif" data-src="https://gitee.com/zxwscoffee/img/raw/master/img/image-20200828202123575.png" align="left"/>



<p>毫无疑问，开发中使用这个注解来实现监听器功能更加方便</p>
<h3 id="EventListener原理"><a href="#EventListener原理" class="headerlink" title="@EventListener原理"></a>@EventListener原理</h3><p><code>@EventListener</code>通过<code>EventListenerMethodProcessor</code>这个后置处理器来实现监听功能</p>
<p><code>EventListenerMethodProcessor</code>的继承关系图如下：</p>
<img src= "/img/loading.gif" data-src="https://gitee.com/zxwscoffee/img/raw/master/img/image-20200828202607833.png" align="left"/>

<p>可以看到，<code>EventListenerMethodProcessor</code>实现了<code>SmartInitialLizingSingleton</code>接口</p>
<h3 id="SmartInitializingSingleton原理"><a href="#SmartInitializingSingleton原理" class="headerlink" title="SmartInitializingSingleton原理"></a>SmartInitializingSingleton原理</h3><p>1）容器创建，调用<code>refresh()</code>方法</p>
<p>2）<code>refresh()</code>方法中调用<code>finishBeanFactoryInitialization(beanFactory)</code>来完成剩余的单实例bean的创建</p>
<p>3）<code>finishBeanFactoryInitialization(beanFactory)</code>方法中调用<code>beanFactory.preInstantiateSingletons()</code>方法来完成剩余非懒加载的单实例bean的创建</p>
<p><code>preInstantiateSingletons()</code>方法中：</p>
<ul>
<li>从BeanFactory中获取所有的bean定义的名称，然后根据这些名称调用<code>getBean</code>方法来创建对应的单实例bean</li>
<li>获取所有的单实例bean，使用for循环来对每个bean进行处理：判断bean是否为<code>SmartInitializingSingleton</code>的示例，如果是则调用<code>smartSingleton.afterSingletonsInstantiated()</code>来执行这个接口的<code>afterSingletonsInstantiated</code>方法</li>
</ul>
<h2 id="Spring容器的创建"><a href="#Spring容器的创建" class="headerlink" title="Spring容器的创建"></a>Spring容器的创建</h2><p>Spring容器的创建也就是<code>refresh()</code>方法（Spring的核心方法）</p>
<h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h3><p><strong>作用</strong>：刷新前的预处理工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录启动的时间</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 设置ApplicationContext开启</span></span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 设置ApplicationContext已激活</span></span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志操作</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initProperySources默认为空实现，可以通过子类来重写这个方法来自定义属性设置方法</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验属性的合法性</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果earlyApplicationListeners为空，则使用applicationListeners为其赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不为空则重置ApplicationListeners到刷新前的状态</span></span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// earlyApplicationEvents赋予初值</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h3><p><strong>作用</strong>：告知子类刷新内置的bean工厂，并返回这个刷新后的bean工厂</p>
<p><code>obtainFreshBeanFactory()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//刷新BeanFactory</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">//得到BeanFactory，返回当前的BeanFactory对象</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>refreshBeanFactory()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置用于序列化的id</span></span><br><span class="line">    <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>this.beanFactory</code>是在何处初始化的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用无参构造来赋值</span></span><br><span class="line">    <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以返回的<code>BeanFactory</code>就是<code>DefaultListableBeanFactory</code>对象</p>
<h3 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory)"></a>prepareBeanFactory(beanFactory)</h3><p><strong>作用</strong>：BeanFactory的预准备工作（BeanFactory进行一些设置）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="comment">// 设置bean的表达式解析器</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    <span class="comment">//添加一个PropertyEditorRegistrar用于所有bean创建的过程</span></span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加ApplicationContextAwareProcessor这个后置处理器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 自动装配时忽略指定接口或类的依赖注入</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册可以解析的自动装配，可以直接在任何组件中自动注入BeanFactory、ResourceLoader、</span></span><br><span class="line">    <span class="comment">// ApplicationEventPublisher、ApplicationContext</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加ApplicationListenerDetector这个后置处理器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加编译时的AspectJ支持</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给BeanFactory中注册一些能用的组件：</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// ConfigurableEnvironment getEnvironment()</span></span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// Map&lt;String, Object&gt; getSystemProperties()</span></span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// Map&lt;String, Object&gt; getSystemEnvironment()</span></span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory)"></a>postProcessBeanFactory(beanFactory)</h3><p><strong>作用</strong>：准备工作完成后进行的后置处理工作</p>
<p>这个方法默认为空实现，也就是说<code>AnnotationConfigApplicationContext</code>类中默认没有这个后置处理；子类可以通过重写这个方法来自定义一些准备工作完成后的后置处理工作！</p>
<p><strong><code>prepareRefresh()</code>、<code>obtainFreshBeanFactory()</code>、<code>prepareBeanFactory(beanFactory)</code>、<code>postProcessBeanFactory(beanFactory)</code>就是BeanFactory的创建和预准备工作！</strong></p>
<h3 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory)"></a>invokeBeanFactoryPostProcessors(beanFactory)</h3><p><strong>作用</strong>：执行<code>BeanFactoryPostProcessor</code></p>
<p><strong>BeanFactoryPostProcessor</strong>：BeanFactory的后置处理器。在BeanFactory的标准初始化后（也就是前面的四个方法执行完成后）调用</p>
<p><strong>两个重要的接口</strong>：<code>BeanFactoryPostProcessor</code>及其子接口<code>BeanDefinitionRegistryPostProcessor</code></p>
<p> 这个方法其实在前面介绍<code>BeanFactoryPostProcessor</code>时已经介绍过了，其处理逻辑如下：</p>
<ul>
<li><p>执行<code>BeanDefinitionRegistryPostProcessor</code>，从容器中获取所有<code>BeanDefinitionRegistryPostProcessor</code>，按照如下的顺序执行</p>
<ul>
<li>实现了<code>PriorityOrdered</code>优先级接口的，按照优先级排序后执行</li>
<li>实现了<code>Ordered</code>顺序接口的，按照顺序排序后执行</li>
<li>没有实现优先级和顺序接口的，最后执行</li>
</ul>
<p><code>BeanDefinitionRegistryPostProcessor</code>的执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanDefinitionRegistryPostProcessors(postProcessors, registry)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>执行<code>BeanFactoryPostProcessor</code>，从容器中获取所有<code>BeanFactoryPostProcessor</code>，按照如下的顺序执行</p>
<ul>
<li>实现了<code>PriorityOrdered</code>优先级接口的，按照优先级排序后执行</li>
<li>实现了<code>Ordered</code>顺序接口的，按照顺序排序后执行</li>
<li>没有实现优先级和顺序接口的，最后执行</li>
</ul>
<p><code>BeanFactoryPostProcessor</code>的执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(postProcessors, beanFactory)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="registerBeanPostProcessors-beanFactory"><a href="#registerBeanPostProcessors-beanFactory" class="headerlink" title="registerBeanPostProcessors(beanFactory)"></a>registerBeanPostProcessors(beanFactory)</h3><p><strong>作用</strong>：注册<code>BeanPostProcessor</code>（Bean的后置处理器）</p>
<p><strong>BeanPostProcessor</strong>：拦截Bean的创建过程的，在Bean的初始化方法执行前后调用</p>
<p>几种常用的<code>BeanPostProcessor</code></p>
<img src= "/img/loading.gif" data-src="https://gitee.com/zxwscoffee/img/raw/master/img/image-20200829100607504.png" align="left"/>

<p>不同接口的Bean后置处理器在Bean创建过程中的<strong>执行时机不同</strong></p>
<ul>
<li><code>BeanPostProcessor</code>：在Bean的初始化方法前后执行</li>
<li><code>InstantiationAwareBeanPostProcessor</code>：在Bean的实例化前后调用</li>
<li><code>DestructionAwareBeanPostProcessor</code>：在Bean的销毁方法执行前调用</li>
<li><code>SmartInstantiationAwareBeanPostProcessor</code>：</li>
<li><code>MergedBeanDefinitionPostProcessor</code>：</li>
</ul>
<p><strong>执行逻辑</strong>：</p>
<p>1）从容器中获取所有的<code>BeanPostProcessor</code>的名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>2）注册一个<code>BeanPostProcessorChecker</code>（也是一个后置处理器）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br></pre></td></tr></table></figure>

<p>3）按照如下顺序对获取到的后置处理器进行分类</p>
<ul>
<li>实现了<code>PriorityOrdered</code>接口但是不是<code>MergedBeanDefinitionPostProcessor</code>这种后置处理器的</li>
<li>实现了<code>Ordered</code>接口但是不是<code>MergedBeanDefinitionPostProcessor</code>这种后置处理器的</li>
<li>剩余的不是<code>MergedBeanDefinitionPostProcessor</code>这种后置处理器的</li>
<li>所有<code>MergedBeanDefinitionPostProcessor</code>这种后置处理器的</li>
</ul>
<p>4）按照上述的顺序先对集合中的后置处理器进行排序，然后将这些后置处理器注册到容器当中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortPostProcessors(postProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, postProcessors);</span><br></pre></td></tr></table></figure>

<p>5）添加一个用于检测<code>ApplicationListener</code>的后置处理器<code>ApplicationListenerDetector</code>，将其添加到后置处理器链的末尾（这个后置处理器是用于检测<code>ApplicationListener</code>，实现AOP的功能！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br></pre></td></tr></table></figure>

<p><strong>注意：注册并不是执行！</strong></p>
<h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource()"></a>initMessageSource()</h3><p><strong>作用</strong>：初始化<code>MessageSource</code>组件（用于国际化功能、消息绑定、消息解析）</p>
<p><strong>执行逻辑</strong>：</p>
<p>1）获取BeanFactory（容器)</p>
<p>2）如果容器中包含id为messageSource的<code>MessageSource</code>类型的对象</p>
<ul>
<li>如果有则赋值给<code>messageSource</code>属性</li>
<li>如果没有则创建一个<code>DelegatingMessageSource</code>赋值给<code>messageSource</code>属性</li>
</ul>
<p><code>MessageSource</code>：能按照区域信息取出国际化配置文件中的某个key值</p>
<p>3）把创建好的MessageSource注册在容器中，以后获取国际化配置文件的时候可以自动注入MessageSource，然后调用<code>getMessage</code>方法来实现国际化</p>
<h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster()"></a><code>initApplicationEventMulticaster()</code></h3><p><strong>作用</strong>：初始化事件派发器</p>
<p><strong>执行逻辑</strong>：</p>
<p>1）获取<code>BeanFactory</code></p>
<p>2）从<code>BeanFactory</code>中获取id为<code>applicationEventMulticaster</code>，类型为<code>ApplicationEventMulticaster</code>的Bean对象</p>
<p>3）如果上一步中没有获取到，则使用<code>new SimpleApplicationEventMulticaster(beanFactory)</code>来创建一个，然后赋予给<code>applicationEventMulticaster</code>属性</p>
<p>4）将创建的bean对象注册到<code>BeanFactory</code>中，以便其他组件自动注入</p>
<h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh()"></a>onRefresh()</h3><p><strong>作用</strong>：这个方法也是一个空实现，提供给子类（子容器）来实现，用于自定义剩余bean的初始化</p>
<h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners()"></a>registerListeners()</h3><p><strong>作用</strong>：向容器中注册项目中所有的监听器</p>
<p><strong>执行逻辑</strong>：</p>
<p>1）从容器中拿到所有的<code>ApplicationListener</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getApplicationListeners()</span><br></pre></td></tr></table></figure>

<p>2）将获取到的<code>ApplicationListener</code>添加到从容器中获取到的事件派发器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br></pre></td></tr></table></figure>

<p>3）派发早期的的监听器</p>
<h3 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory)"></a>finishBeanFactoryInitialization(beanFactory)</h3><p><strong>作用</strong>：初始化所有剩下的单实例bean</p>
<p><strong>执行逻辑</strong>：</p>
<p>1）实例化<code>conversionService</code></p>
<p>2）如果容器中没有<code>EmbeddedValueResolver</code>，就向容器中注册一个</p>
<p>3）获取<code>LoadTimeWeaverAware</code>类型的<code>BeanDefinition</code>，提前实例化</p>
<p>4）停止使用用于类型匹配的临时<code>ClassLoader</code></p>
<p>5）冻结上下文，不允许再修改配置</p>
<p>6）实例化剩余的非懒加载的单实例bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure>



<h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons()"></a>preInstantiateSingletons()</h4><p>1）获取容器中所有的定义的Bean的名称</p>
<p>2）获取Bean的定义信息：<code>RootBeanDefinition</code>类型对象<code>bd</code></p>
<p>3）初始化所有的非懒加载的Bean</p>
<ul>
<li>首先判断<code>bd</code>是否是非抽象的，单实例的，是非懒加载的<ul>
<li>如果是判断对应的Bean是否实现了<code>FactoryBean</code>接口，如果是则使用<code>FactoryBean</code>的<code>getObject</code>方法来创建Bean对象</li>
<li>如果不是工厂Bean则利用<a href="#getBean(beanName"><code>getBean</code></a>方法来创建Bean对象</li>
</ul>
</li>
</ul>
<p>4）对所有合适的Bean执行Bean初始化后的回调方法</p>
<ul>
<li>判断Bean是否实现了<code>SmartInitializingSingleton</code>接口，如果是则调用其<code>afterSingletonsInstantiated</code>方法来进行Bean初始化后的后置处理</li>
</ul>
<h4 id="getBean-beanName"><a href="#getBean-beanName" class="headerlink" title="getBean(beanName)"></a>getBean(beanName)</h4><p><code>getBean(beanName)</code>中调用了<code>doGetBean(name, null, args, false)</code>方法，其<strong>执行流程</strong>如下：</p>
<p>1）先获取缓存中保存的单实例Bean，如果能够获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）</p>
<p>从<code>Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</code>这个属性中获取缓存的单实例Bean</p>
<p>2）缓存中获取不到，则开始创建Bean的流程</p>
<ul>
<li><p>标记当前Bean已经被创建（防止多线程重复创建Bean）</p>
</li>
<li><p>获取Bean的定义信息</p>
</li>
<li><p>获取当前Bean所依赖的其他Bean，如果有则使用<code>getBean</code>方法创建所依赖的Bean</p>
</li>
<li><p>启动单实例Bean创建流程，调用<code>createBean(beanName, mbd, args)</code>创建单实例Bean</p>
<ul>
<li><p>首先，给后置处理器（<code>BeanPostProcessor</code>）一个机会返回一个目标Bean实例的代理对象，如果获取到了代理对象则返回这个代理对象（这个后置处理器是<strong><code>InstantiationAwareBeanPostProcessor</code></strong>，这个后置处理器中的方法会在Bean实例化之前就调用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br></pre></td></tr></table></figure>

<ul>
<li>首先执行<code>postProcessBeforeInstantiation</code>方法</li>
</ul>
</li>
<li><p>如果上面的方法有返回值（不为null），则执行<code>postProcessAfterInitialization</code>方法</p>
</li>
<li><p>调用<a href="#doCreateBean(beanName, mbdToUse, args)"><code>doCreateBean</code></a>方法创建Bean</p>
</li>
</ul>
</li>
</ul>
<p>3）如果成功创建了单实例Bean，则将这个单实例Bean放入到单实例Bean的缓存中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingleton(beanName, singletonObject);</span><br></pre></td></tr></table></figure>



<h4 id="doCreateBean-beanName-mbdToUse-args"><a href="#doCreateBean-beanName-mbdToUse-args" class="headerlink" title="doCreateBean(beanName, mbdToUse, args)"></a>doCreateBean(beanName, mbdToUse, args)</h4><p><code>doCreateBean</code>用于创建Bean，其<strong>执行流程</strong>如下：</p>
<p>1）<strong>Bean实例化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">//如果Bean定义为单例，则从容器的属性中获取对应的BeanWrapper对象</span></span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果没有获取到，则使用beanName和Bean定义来创建一个对应的BeanWrapper对象</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取BeanWrapper中封装的Object对象，也就是获取到bean对象的实例</span></span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">//获取BeanWrapper中封装的bean的Class</span></span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将Bean的类型设置到Bean定义的目标类型中</span></span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）允许后置处理器（<code>MergedBeanDefinitionPostProcessor</code>）来处理符合条件的Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br></pre></td></tr></table></figure>

<p>这个方法会调用<code>MergedBeanDefinitionPostProcessor</code>的<code>postProcessMergedBeanDefinition</code>方法</p>
<p>3）为<strong>Bean的属性赋值</strong>：<code>populateBean(beanName, mbd, instanceWrapper)</code></p>
<ol>
<li>拿到<code>InstantiationAwareBeanPostProcessor</code>后置处理器，执行其<code>postProcessAfterInstantiation</code>方法</li>
<li>拿到<code>InstantiationAwareBeanPostProcessor</code>后置处理器，执行其<code>postProcessProperties</code>方法，执行<code>postProcessPropertyValues</code>方法，得到<code>PropertyValues</code>对象</li>
<li>调用<code>applyPropertyValues(beanName, mbd, bw, pvs)</code>方法将获取到的属性应用到Bean中（为属性利用setter方法进行赋值）</li>
</ol>
<p>4）<strong>Bean初始化</strong>：<code>exposedObject = initializeBean(beanName, exposedObject, mbd)</code></p>
<ol>
<li><p>执行Bean中实现的XXXAware接口中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeAwareMethods(beanName, bean);</span><br></pre></td></tr></table></figure>

<p>按照：BeanNameAware、BeanClassLoaderAware、BeanFactoryAware的顺序依次注入对应的组件</p>
</li>
<li><p>执行后置处理器（<code>BeanPostProcessor</code>）的<code>postProcessBeforeInitialization</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行Bean的初始化方法：<code>invokeInitMethods(beanName, wrappedBean, mbd)</code></p>
<ul>
<li>是否是<code>InitializingBean</code>接口的实现，执行接口规定的初始化方法</li>
<li>如果不是，则从Bean定义中获取自定义的初始化方法并执行</li>
</ul>
</li>
<li><p>执行后置处理器（<code>BeanPostProcessor</code>）的<code>postProcessAfterInitialization</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后返回这个经过重重包装的<code>wrappedBean</code>对象</p>
</li>
</ol>
<p>5）注册Bean的销毁方法：<code>registerDisposableBeanIfNecessary(beanName, bean, mbd)</code></p>
<ul>
<li><p>如果Bean实现了<code>Disposable</code>接口，则将这个Bean添加到<code>disposableBeans</code>属性（一个Map集合，以beanName为键，以Bean为值，存储了可以执行销毁方法的Bean的Map集合）</p>
<p><strong>注意</strong>：这里只是注册了可以执行销毁方法的Bean，会在Bean被销毁时执行这些Bean的销毁方法</p>
</li>
</ul>
<h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh()"></a>finishRefresh()</h3><p><strong>作用</strong>：完成BeanFactory的初始化创建工作，IoC容器就创建完成</p>
<p>1）清空context级别的资源缓存（resource cache）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearResourceCaches();</span><br></pre></td></tr></table></figure>

<p>2）初始化和生命周期有关的后置处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initLifecycleProcessor();</span><br></pre></td></tr></table></figure>

<p><code>LifecycleProcessor</code>接口的方法：</p>
<ul>
<li><code>onRefresh()</code>：在容器刷新时拦截</li>
<li><code>onClose()</code>：在容器关闭时拦截</li>
</ul>
<p><code>initLifecycleProcessor()</code>默认会从容器中查找是否有<code>LifecycleProcessor</code>类型的Bean，</p>
<p>如果没有则创建<code>DefaultLifecycleProcessor</code>的组件，并注册到容器中</p>
<p>3）调用生命周期处理器的<code>onRefresh()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getLifecycleProcessor().onRefresh();</span><br></pre></td></tr></table></figure>

<p>4）派发容器刷新完成事件（<code>ContextRefreshedEvent</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>

<p>5）<code>LiveBeansView.registerApplicationContext(this);</code></p>
<h2 id="Spring源码总结"><a href="#Spring源码总结" class="headerlink" title="Spring源码总结"></a>Spring源码总结</h2><ol>
<li><p>Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息</p>
<p>1）使用xml注册Bean</p>
<p>2）使用注解注册Bean：@Service、@Component、@Bean….</p>
</li>
<li><p>Spring容器会在合适的时机创建这些Bean</p>
<p>1）在用到这些Bean的时候：利用<code>getBean</code>方法创建这个Bean，创建好以后保存到容器中</p>
<p>2）统一创建剩下所有的非懒加载的、单实例的Bean</p>
</li>
<li><p><strong>后置处理器</strong>：</p>
<p>每一个Bean创建完成以后，都会使用<strong>各种后置处理器</strong>进行处理来<strong>增强Bean的功能</strong></p>
<p><code>AutowiredAnnotationBeanPostProcessor</code>：处理自动注入</p>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>：实现AOP</p>
<p>…</p>
</li>
<li><p>事件驱动模型</p>
<p><code>ApplicationListener</code>：事件监听器</p>
<p><code>ApplicationEventMulticaster</code>：事件多播器（派发器）</p>
</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">折木Zxw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://zxwzxh.github.io/2020/08/26/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-%E6%89%A9%E5%B1%95%E5%8E%9F%E7%90%86/">http://zxwzxh.github.io/2020/08/26/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-%E6%89%A9%E5%B1%95%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zxwzxh.github.io" target="_blank">折木Zxw</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/">Spring注解驱动</a><a class="post-meta__tags" href="/tags/%E6%89%A9%E5%B1%95%E5%8E%9F%E7%90%86/">扩展原理</a><a class="post-meta__tags" href="/tags/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/">Spring容器的创建流程</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/01/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-web/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring注解驱动-web</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/24/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring注解驱动-声明式事务</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/17/Spring注解驱动开发（三）/" title="Spring注解驱动开发（三）"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-17</div><div class="relatedPosts_title">Spring注解驱动开发（三）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/24/Spring注解驱动-声明式事务/" title="Spring注解驱动-声明式事务"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-24</div><div class="relatedPosts_title">Spring注解驱动-声明式事务</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/01/Spring注解驱动-web/" title="Spring注解驱动-web"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-01</div><div class="relatedPosts_title">Spring注解驱动-web</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 折木Zxw</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script></body></html>